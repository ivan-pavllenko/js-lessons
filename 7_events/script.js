'use strict';
//! События  
//? События - это сигнал от браузера о том что что-то у нас произошло 
//? События - это клик, двойной клик, наведение мыши, убрать мышь с элемента, прокрутка колесиком мыши, отправка данных формы
//? Чтобы использовать любое событие мы должны назначить обработчик событий
//? Обработчик - это ф-я которая срабатывает как только событие произошло
//? Пример: если поль-ль совершает щелчок мыши на гамбургер меню то у нас срабатывает ф-я которая открывает это меню

//* const btn = document.querySelector('button'),
//*   overlay = document.querySelector('.overlay');


//! в js всего 3 способа назначить обработчики событий 

//!  1-й html атрибут который записывается прямо в верстке (в реальных проектах не используется)
//* onclick = "alert('Click')"


//!  2-й (в реальных проектах не используется)

//* btn.onclick = function () {
//*   alert('Click');
//* };

//* btn.onclick = function () {
//*   alert('Second click');
//* };

//?  Проблемы которые могут возникнуть
//?  1) Если у нас большой код то мы получаем сразу второе действие alert('Second click');
//?  Если мы повторяем такое свойство, то оно заменяет первым 
//?  2) Мы не сможем удалить такое событие

//!  3-й с помощью методов addEventListener и removeEventListener

//! addEventListener - добавляет обработчики на страницу
//! removeEventListener - позволяет удалять обработчики со страницы

//?  метод addEventListener - говорит что мы добавляем обработчик события, слушателя за событиями
//?  js будет следить за этим эл-м, и если у нас произошло это событие, то он запустит обработчик
//?  1-м аргументом передаем название события 'click'
//?  2-м аргументом передаем callback ф-ю, которая и будет нашим обработчиком

//? + этого метода: Мы можем назначать несколько действий на одно событие
//? 1-е действие мы не потеряли, оно будет работать точно также со 2-м

//* btn.addEventListener('click', () => {
//*   alert('Click');
//* });

//* btn.addEventListener('click', () => {
//*   alert('Second click');
//* });

//? События в js выполняются в порядке очереди
//? Как только у нас новое событие поступило, оно добавляется в очередь независимо от других событий

//? Если я введу действие mouseenter, я буду выполнять эту ф-ю каждый раз, когда поль-ль наводит мышку на этот эл-т

//* btn.addEventListener('mouseenter', () => {
//*   console.log('Hover');
//* });

//? Помимо этого, иногда нам необходимо получать данные об эл-те с которым мы взаимодействуем
//? Например: что за событие сейчас произошло? что за эл-т сейчас используется?
//? Для этого есть специальный обьект, который наз-ся event
//? Этот обьект события передается как аргумент в callback ф-ю
//? Называть мы его можем как угодно, обычно называют event или e
//? Всегда передается 1-м аргументом

//* btn.addEventListener('mouseenter', (e) => {
//*   console.log(e);
//* });

//? Мы получаем обьект MouseEvent, который описывает что произошло с эл-м
//? Самых важные свойства, которые мы можем здесь увидеть - это
//! type: тот тип события, который произошел type: "mouseenter"
//! target: тот эл-т на котором произошло событие target: button#btn
//? Эти свойства мы будем часто использовать

//? Можно прописать и сразу получить доступ к этому эл-ту 
//? И теперь мы можем с этим эл-м что-то сделать. Например: перекрасить его, поменять ему класс или удалить со стр-цы 
//! e.target.remove(); наводим на эл-т и он пропадает со страницы

//* btn.addEventListener('mouseenter', (e) => {
//*   console.log(e.target);
//*   e.target.remove();
//* });

//? Иногда нам нужно удалять обработчики событий, для этого есть метод removeEventListener
//? Но здесь есть одна загвоздка, то что нам необходимо использовать точно такую же ф-ю (e), которую мы назначали при помощи addEventListener 
//? Когда то была задача, равны ли два массива, имея едентичные внутренности - нет, не равны
//? Если мы два раза напишем одну и туже ф-ю (e), это не одна и таже ф-я, а две разные 
//? Поэтому чтобы иметь возможность удалить ф-ю нам необходимо её вынести в отдельную переменную

//* const deleteElement = (e) => {
//*   e.target.remove();
//* };

//* btn.addEventListener('click', deleteElement);

//? После того как у нас выполнится click по эл-ту btn у нас выполнится ф-я deleteElement

//* const element = (e) => {
//*   console.log(e.target);
//* };

//* btn.addEventListener('click', element);
//* btn.removeEventListener('click', element);

//? Логика такая, что мы назначаем обработчик и сразу же его удаляем
//? Сейчас на странице ничего не должно происходить

//? При клике на кнопку срабатывает обраб событий i = 0, при клике второй раз сработает условие i == 1 обраб-к соб-й удаляется и больше ничего не будет происходить

//* let i = 0;
//* const element = (e) => {
//*   console.log(e.target);
//*   i++;
//*   if (i == 1) {
//*     btn.removeEventListener('click', element);
//*   }

//* };

//* btn.addEventListener('click', element);

//!  Всплытие событий
//?  У нас есть два эл-та, один из них яляется родителем. Но при этом на них назначены обраб-ки соб-я которые выполняют одно и тоже действие

//?  Какое будет поведение?
//?  К консоль мы получим:
//?  <button id="btn">Нажми меня</button> click
//?  <button id="btn">Нажми меня</button> click

//?  Сначала сработало на том эл-те, который идёт вложенней и после этого по ерархии оно поднялось и сработало на розовом overlay - это и наз-ся всплытие событий 

//?  Всплытие событий - это когда обработчик сначала срабатывает на самом вложенном эл-те затем на родителей и так выше и выше по иерархии DOM дерева 

//?  Каждый раз когда в консоль выводится console.log(e.target); мы ссылаемся на эл-т на котором произошло изначально событие <button id="btn">Нажми меня</button>

//?  Но это поведение можно подправить: использовать свойство currentTarget

//!  Свойство currentTarget позволяет увидеть порядок всплытия событий

//?  К консоль мы получим:
//?  <button id="btn">Нажми меня</button> click
//?  <div class="overlay"></div> click

//?  Теперь видно как это событие всплывает наверх

//* const element = (e) => {
//*   console.log(e.currentTarget);
//*   console.log(e.type);
//* };

//* btn.addEventListener('click', element);
//* overlay.addEventListener('click', element);

//?  Мы можем отменять стандартное поведение браузера
//?  Предполагает использование метода, который существует у обьекта события (e)

//!  preventDefault - метод который говорит, браузер стой, нам не нужно переходить по ссылке, мы будем делать другие действия, которые сказал нам программист

//?  event.preventDefault - помещается в самое начало обработчика событий
//?  Теперь при клике на ссылку она не будет переходить на другую страницу, а выводить инф-я о элементе

const link = document.querySelector('a');

link.addEventListener('click', function (event) {
  event.preventDefault();
  console.log(event.target);
});

//!  Ошибка, которую многие допускают
//?  Если у нас стоит задача один и тот же функционал навесить на несколько элементов

//?  const btn = document.querySelectorAll('button')
//?  btn.addEventListener('click', element);

//?  У переменной button не существует такого метода как addEventListener
//?  Потому что в переменной button лежит сейчас псевдомассив, мы его получили при помощи querySelectorAll('button')
//?  Поэтому чтобы сраза не несколько эл-тов вешать обработчик событий, нам необходимо полностью этот псевдомассив querySelectorAll('button') перебрать, элемент за элементом, и на каждый эл-т внутри навесить обработчики

const btns = document.querySelectorAll('button');

const element = (e) => {
  console.log(e.currentTarget);
  console.log(e.type);
};

//?  Перемеберем при помощи forEach, точно также можно перебрать при помощи for of

btns.forEach(btn => {
  btn.addEventListener('click', element, {
    once: true
  });
});

//!  Опции события
//?  У addEventListener существует и 3-й аргумент, это обьект в котором мы можем передать различные опции
//!  Опция once - говорит что событие может произойти только один раз
//?  Опция once - хорошая альтернатива removeEventListener
//?  Потому что не нужно прописывать конструкции, а просто можем передать этот обьект с такими настройками