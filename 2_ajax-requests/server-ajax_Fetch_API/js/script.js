//!  Fetch API
//?  Fetch API - это нативная возможность, которую можно использовать внутри js, она уже в него встроена, без подключения библиотек и сторонних ресурсов, точно также как мы использовали XMLHttpRequest
//?  Fetch API - работает на промисах
//?  Если есть промисы мы можем избавится о понятия call back hell(цепочка колбеков) - при выполнении уловия выполнится следущее условие и т.д.  
//? Если мы не передаём какие-то дополнительные опции, то у нас просто идёт GET запрос по данному адресу

//? Команда  data.json возвращает промис, который мы можем обработать в цепочке then
//? Из этого промиса у нас возвращаются какие-то данные в самом обычном варианте, не json
//? Чтобы их увидеть мы можем в console.log пометить data - console.log(data)

//! Что тут происходит
//? Мы посылаем запрос по адресу http://localhost:3000/people
//? Когда к нам возвращается промис из этого запроса, мы его можем обратотать
//? Промис имеет 2 результата - успешный и не успешный
//? Успешный запрос - это когда сервер вернул ответ и всё ок
//? Не успешный запрос - ошибка в указанном пути, может лечь сервер
//? Заппрос прошел успешно, мы получаем определенные данные
//? Из формата json мы их превращаем в обычный обьект .then(data => data.json())
//? Выводим их в консоль .then(data => console.log(data));
//? При помощи catch обработаем ошибку, если что-то пойдет не так, к нам вернется обьект ошибки и мы его при помощи console.error выведим в консоль

//? Оптимизируем запросы с промисами, каждый раз когда я должен буду сделать запрос, мне придётся повторять код
//*  fetch("http://localhost:3000/people") //?запрос к серверу
//*    .then(data => data.json()) //? превращаем данные из формата json в обычный обьект
//? Чтобы код не повторять, создадим вспомогательную ф-ю getResourse
//? В эту ф-ю мы будем передавать url - тоесть куда мы будем делать запрос 
//? Дальше нам необходимо его выполнить. cоздаём переменную  const res во внутрь передаем тот url который необходимо зафечить
//? Теперь я могу вместо fetch("http://localhost:3000/people") вызывать ф-ю  getResourse
//? Внутри ф-и getResourse я хочу проверить выполнился ли запрос успешно, но тут мы столкнемся с проблемой
//? Это асинхронность при работе с сервером

//! Как всё будет происходить когда я запускаю ф-ю getResourse
//? Она получает определённый url в виде аргумента
//? Запускается const res = fetch(`${url}`) начинается всё с правой части - мы запускаем fetch
//? fetch отправляет запрос по адресу url, мы предполагаем что тот запрос который был нами послан вернет нам промис, этот промис запишется в переменную res,
//? и дальше мы можем выполнять определённые операции, например вернуть этот промис return res;

//! Нельзя забывать что операция  fetch - является асинхронной, сервер не может мгновенно отвечать, ему необходимо определённое время чтобы дать ответ, js  этого не знает
//?  js отправит запрос внутри  fetch(`${url}`) , начнёт создавать пер-ю res, так как в  fetch(`${url}`) ничего нет нам вернется undefined, она будет пустая - и здесь нам нужно учитывать асинхронность
//?  Будем использовать операторы - async  
//? если в ф-и есть какая-то асинхронная операция, перед ф-ей записываем - async
//? и чтобы сказать какая именно мы записываем await
//? Оператор await - позволяет сказать js что сейчас эту операцию fetch(`${url}`) нужно дождаться
//? Теперь мы посылаем запрос fetch(`${url}`) , наш код дожидает ответаот сервера, и после того как мы получим  тут результат начинает создание переменной res
//?Теперь мы можем использовать пер-ю res, воспользуемся условием, я спрошу
//? Внутри fetch у res появляется свойство ok - нам возвращает то что всё прошло успешно
//? Здесь мы можем проверить, если запрос прошёл не успешно - мы выведим ошибку 
//? Когда fetch получает ошибку он нам не возвращает что именно там произошло (какой статус)
//? Поэтоиу мы вручную выделим статус  ${res.status}

//! У нас ещё одна проблема каждый раз нам необходимо выполнять операцию .then(data => data.json())
//? От этого можно избавится в строчке return await res.json();
//? Я скажу что буду возвращать res.json(); здесь в json() возвращается тоже промис, поэтому нам нужно дождаться await когда наш код полностью завершит операцию по превращению с  json() в обычный обьект
//? Теперь мы можем оптимизировать наш код, мы берем  getResourse и подставляем сюда fetch("http://localhost:3000/people") 
//? getResourse("http://localhost:3000/people")



window.addEventListener("DOMContentLoaded", () => {
  function req() {

    //   const request = new XMLHttpRequest();
    //   request.open("GET", "http://localhost:3000/people");
    //   request.setRequestHeader("Content-type", "application/json;charset=utf-8"); //? установим заголовок 
    //   request.send(); //? запрос ушел на сервер

    //   request.addEventListener("load", function () {
    //     if (request.status == 200) {
    //       let data = JSON.parse(request.response);
    //       console.log(data);
    //       createCards(data);

    //     } else {
    //       console.error("Что-то пошло не так");
    //     }
    //   });


    // fetch("http://localhost:3000/people")  //? запрос к серверу
    // .then(data => data.json()) //?превращаем данные из формата json в обычный обьект
    // .then(data => console.log(data)); //? выводим данные в консоль

    getResourse("http://localhost:3000/people") //? запрос к серверу
      .then(data => createCards(data)) //? мы получаем данные и записываем их в data
      .catch(err => console.error(err)); //? при помощи catch обработаем ошибку


    this.remove(); //? Удаляем кнопку после того как мы на неё кликнули, 
  }

  document.querySelector("button").addEventListener("click", req, {
    "once": true
  });

  async function getResourse(url) {
    const res = await fetch(`${url}`);

    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);

    }

    return await res.json(); //?  await говорит, дождись завершение операции res.json() и только потом возвращай

  }

  function createCards(response) {
    response.forEach(item => {

      let card = document.createElement('div');

      card.classList.add('card');

      let icon;
      if (item.sex === "male") {
        icon = "icons/mars.png";
      } else {
        icon = "icons/female.png";
      }

      card.innerHTML = `
          <img src ="${item.photo}" alt ="photo" />
          <div class="name">${item.name} ${item.surname}</div>
          <div class="sex">
          <img src="${icon}" alt="male" />
          </div>
          <div class="age">${item.age}</div>
          `;
      document.querySelector('.app').appendChild(card);
    });



  }
});