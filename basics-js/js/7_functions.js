//! Функции

//? В {} действия которые должна эта функция выполнить
//? В () аргументы

// function humanSayHello() {
//   console.log('Hello World!');
// }

// humanSayHello(); //? запускаем функцию

//? Теперь когда я вызову эту функцию я могу передать туда аргумент, не важно что это сейчас, а самое главное что --- "Я могу передать туда что то , и это что то будет использовано во время работы этой ф-и"

function humanSayHello(user) {
  console.log('Hello ' + user + '!');
}

humanSayHello('Ivan'); //? Hello Ivan!


//! Функции
//? Имя функции должно быть глаголом с предписком того над чем выполняется действие
//? showFirstmassage - показать первое сообщение
//! Аргумент
//? Когда ф-я вызывается, мы можем дать ей какие то данные которые она будет использовать внутри себя
//? Пример калькулятор, аргумент 2 и 5

//? Если мы обьявляем перемннную внутри ф-и то снаружи она недоступна, доступна только внутри блока с {}

function showFirstmassage(text) {
  console.log(text);
  let numb = 10; //? локальная пер-я
}
console.log(numb); //? глобальная пер-я

//? Локальная пер-я - переменная создана внутри ф-и 
//? Глобальная пер-я - переменная создана снаружи ф-и 

//? Любая ф-я может использовать пер-ю внутри себя

let num = 20;

function showFirstmassage(text) {
  console.log(text);
  num = 10; //? здесь мы используем глобальную пер-ю, мы её не обьявляем
}

showFirstmassage('Hello world!');
console.log(num); //? будет Hello world! 10 , внутри ф-и когда она выпонилась у нас было изменено значение num

//? Обращается к глобальной пер-й, она ничего не знает о локальной пер-й

let number = 20;

function showFirstmassage(text) {
  console.log(text);
  let number = 10;
}

showFirstmassage('Hello world!');
console.log(number); //? будет 20, обращается к глобальной пер-й, она ничего не знает о локальной пер-й


//? Сначала выведет с глобальной пер 20 потом с локальной пер 10 

let numberr = 20;

function showFirstmassage(text) {
  console.log(text);
  let numberr = 10;
  console.log(numberr);
}

showFirstmassage('Hello world!');
console.log(numberr); //? будет 10 20, сначала выведет с глобальной пер 20 потом с локальной пер 10 

//? Если удалить локальную пер-ю let numberr = 10;
//? Когда дойдёт до команды console.log(numberrr); она сканирует эту ф-ю и внутри себя не найдет пер-ю numberrr, в таком случае эта ф-я начнёт искать на уровень выше и использует глобальную пер-ю

let numberrr = 20;

function showFirstmassage(text) {
  console.log(text);
  console.log(numberrr);
}

showFirstmassage('Hello world!');
console.log(numberrr); //? будет 20  20

//? Когда ф-я вызывается, она пытается найти пер-е, если она не находит то она постоянно идет на уровень выше
//? Замыкание ф-и - это сама ф-я вместе со всеми внешними переменными, которые ей доступны

//! Создаем калькулятор
//? Аргументов может быть бесконечное количество, сайчас (a, b)

function calc(a, b) {
  console.log(a + b);
}

calc(4, 5);
calc(4, 8);
calc(14, 5);

//? Основное предназначения ф-и - каждый раз получать новый результат не дублируя код

//! return
//? return -- наша ф-я калькулятор посчитает значение a + b и вернет его из нашей ф-и, она может вернуть только ответ, не выводит в консоль, не пишет значене на экран, а просто возвращает число - и теперь мы можем его использовать

//? Как только ф-я увидит return она прекратит свое действие

function calc(a, b) {
  return (a + b);
  console.log('scs');

}
console.log(calc(5, 6));
console.log(calc(3, 2));
console.log(calc(5, 5));

//? Кокда запустится ф-я calc, она нам вернет суммму 1го и 2-го аргументв
//? Теперь мы её можем переиспользовать много много раз
//? Каждый раз нам возвращается сумма двух аргументов
//? Слово return позволяет вернуть значение во внешний мир (наружу)
//? Если ниже return написать код, то он никогда не выполнится, после return мы ничего не задаем


//? Во внешний мир наша ф-я возвращает значение своей локальной переменной
//? Возвращаем результат и записываем его во внутрь пер-й anotherNum 

function ret() {
  let num = 30;
  return num;
}

const anotherNum = ret();
console.log(anotherNum);

//! Классификации ф-й
//? Обьявляем ф-ю обычным способом или записываем в формате функционального выражнния

//! function Declaration
//? function Declaration - создается до начала выполнения скрипта, можно вызвать перед обьявлением (как var)
//? Иногда разработчики все ф-и помещают в самый низ страницы, а сверху просто используют

humanSayHello('Ivan');

function humanSayHello(user) {
  console.log('Hello ' + user + '!');
}
//? когда создаем function Declaration ; не нужно ставить

//! function Expression
//? function Expression ( функциональное выражение) - создается только тогда, когда доходит поток кода, можно вызвать только после обьявления

const logger = function () {
  console.log('Hello');
};

logger();

//! Стрелочные ф-и ()=>
//? Стрелочные ф-и не имеют контекста вызова
//? сокращенный вариант
const culcc = (a, b) => a + b;

//? Создаем пер-ю const culcc в которую помещаем ф-ю, ф-я у нас стелочная
//? = знак присваивание, в () скобки помещаем два аргумента (a, b)
//? Если запись ф-и в одну строчку мы скобки {} можем не записывать

//? по классике
const culce = (a, b) => {
  console.log('1');
  return a + b;
};

//? действие которое выполняем записываем в {} это return a + b;