'use strict';
//! Передача по ссылке или по значению, Spread оператор(ES6 - ES9)

//? Когда мы работаем с примитивными типами данными (строки, числа, логических значений)

let a = 5,
  b = a; //? сдесь передача по значению

b = b + 5;

console.log(a); //? будет 5
console.log(b); //? будет 10

//? Когда мы работаем с с обьектами (обьекты, мвссивы, ф-и, даты)

const obj = {
  a: 5,
  b: 1
};

const copyy = obj; //? мы сдесь не скопировали новый обьект, а передаем новое значение по ссылке

copyy.a = 10;

console.log(copyy); //? будет { a: 10, b: 1 }
console.log(obj); //? будет { a: 10, b: 1 }

//? В консоль выводится два абсолютно однинаковых обьекта
//? Хотя по идеи мы создали копию (copy) и модифицировали уже копию, а не сам изначальный обьект (obj)
//? Мы видим что изменяя что-то внутри copy.a = 10; мы мод-ем наш изначальный обьект

//! Нужно понять
//? Когда мы работаем с примитивными типами данными (строки, числа, логических значений), то они передаются по значению, проще говоря когда мы b = a; b будет 5
//? Когда мы работаем с обьектами (обьекты, мвссивы, ф-и, даты), то у нас идет передача не по значению, а по ссылке
//? Это значит что const copy = obj; передает не саму структуру обьекта, а передает ссылку на сущес-щий обьект
//? Мод-я копию мы мод-ем наш изначальный обьект, потому-что мы работаем не скопией , а с ссылкой на обьект

//! Как же создавать копии обьектов, массивов?

//! 1-й способ создавать копию обьекта - использование цикла
//? При помощи цикла эта ф-я создаст новый обьект, уже перебирая старые свойства которые были уже в нашем обьекте

function copy(mainObj) {
  let objCopy = {}; //? создадим копию нового обьекта

  //? запускаем перебирающую конструкцию for in
  let key;
  //? во внутрь помещаем копирование наших свойств
  //? в objCopy (он сейчас пустой) создаем новое свойство
  //? делаем копию из нашего главного обьекта mainObj[key]
  //? Мы пройдемся по старому нашему обьекту mainObj[key], скопируем все свойства которые там есть и поместим их в нашу новую копию, которая изначально была пустым обьектом
  for (key in mainObj) {
    objCopy[key] = mainObj[key];
  }

  //? Возвращаем objCopy наружу
  return objCopy;
}

const numbers = {
  a: 7,
  b: 20,
  c: {
    x: 7,
    y: 4
  }
};

//? Создадим новую пер-ю и воспользуемся ф-ей copyy, она примет обьект numbers и вернет нам новый обьект, который будет копией

const newNumbers = copy(numbers); //? клонировали наш обьект

newNumbers.a = 10;

console.log(newNumbers); //? будет { a: 10, b: 20, c: { x: 7, y: 4 } }
console.log(numbers); //? будет { a: 7, b: 20, c: { x: 7, y: 4 } }

newNumbers.c.x = 15; //? x изменится в двух местах

console.log(newNumbers); //? будет { a: 10, b: 20, c: { x: 15, y: 4 } }
console.log(numbers); //? будет { a: 7, b: 20, c: { x: 15, y: 4 } }

//! Запомнить
//? Когда мы клонируем обьекты, есть два очень важных понятия: глубокие и поверхностные копии обьектов
//? Сейчас мы создали поверхностную копию, она берет свойтсва родителя и создает независимую структуру
//? Но как только появляется вложенная структура, то это свойство будет иметь ссылочный тип данных
//? Будем нормально работать только с теми свойствами которые лежат на первом уровне


//! 2-й способ создавать копию обьекта Object.assign
//? Object.assign - позволяет соеденить сразу несколько обьектов
const add = {
  d: 25,
  e: 30
};

console.log(Object.assign(numbers, add)); //? будет { a: 7, b: 20, c: { x: 15, y: 4 }, d: 25, e: 30 }

//? Два обьекта соединились, мы создали независимую поверхностную копию обьектов
//? 1-м аргуменом идет тот обьект в который мы хотим поместить
//? 2-м аргуменом идет тот обьект который мы помещаем

//? Тоже самое мы можем сделать с пустым обьектом чтобы создать просто копию обьекта 
//? numbers заменяем на пустой обьект {} таким образом у нас создается новый обьект, 
//? в него помещается какой то старый обьект add и мы получаем какую-то отдельную копию

const clone = Object.assign({}, add);

clone.d = 20;

console.log(add); //? будет { d: 25, e: 30 }
console.log(clone); //? будет { d: 20, e: 30 }

//? В clone лежит поверхностная копия преведущего обьекта

//! //! 3-й способ создавать копию массива с помощью свойства slice()

const oldArray = ['a', 'b', 'c'];
const newArray = oldArray.slice();

newArray[1] = 'welcome to learn js';

console.log(oldArray); //? будет [ 'a', 'b', 'c' ]
console.log(newArray); //? будет [ 'a', 'welcome to learn js', 'c' ]

//? Получаем 2 абсолютно разных массива

//! // 4-й способ создавать копию (обьекта и массива) с помощью spret - оператора разворота
//? // Этот оператор разворачивает структуру и правращает её в набор каких то данных 

const video = ['youtube', 'vimeo', 'rutube'],
  blogs = ['wordpress', 'livejournal', 'blogger'],
  internet = [...video, ...blogs, 'instagram', 'facebook'];

//? В пер-й internet будут значения из пер-й video + пер-й blogs + свои значения
console.log(internet);

//? Оператор разворота развернул эти структуры на отдельные эл-ты

//? Пример - разложение массива на 3 отдельных элемента
function log(a, b, c) {
  console.log(a);
  console.log(b);
  console.log(c);
}

const num = ['https://www.youtube.com/', 'youtube', 7];

//? Этот массив пришел из сервера (данные о видео)
//? Эти 3 аргумента нам нужно передать в ф-ю log
//? Как это сделать ведь ф-я принимает 3 отдельных эл-та, она не принимает массив
//? Здесь нам помогает spret оператор, массив разложится на 3 отдельных элемента

log(...num); //? будет https://www.youtube.com/ youtube 7
// log(num); //? будет ['https://www.youtube.com/', 'youtube', 7] undefined undefined


//! создание поверхностной копии массива

const array = ['a', 'b'];

const newArrayy = [...array];

console.log(newArrayy); //? будет [ 'a', 'b' ]

//! создание поверхностной копии обьекта

const q = {
  one: 1,
  two: 1
};

const qNew = {
  ...q
};

console.log(qNew); //? будет { one: 1, two: 1 }